"""
This is a second slice of Clue that is focused on simply giving instructions.
"""


class ClueTracker:
    """
    This object will allow a player to keep track of the information provided
    throughout the game, and make deductions about the unknown cards.
    """

    def __init__(self, players, suspects, weapons, rooms, hand, cpu_suspect):
        self.cards = suspects + weapons + rooms
        self.links = []
        self.players = players
        self.tally_sheet = {
            player: {card: None for card in self.cards} for player in players
        }

        self.hand_size = len(self.cards) // len(players) if len(players) else 0
        for card in hand:
            self.store_revealed_card(cpu_suspect, card)

    def draw_sheet(self, filename):
        from PIL import Image, ImageDraw, ImageFont

        def get_tile_color(tile):
            tile_colors = {
                True: (211, 174, 141),  # light brown for True
                False: (244, 91, 96),  # soft red for False
                None: (238, 228, 210),  # light cream for Unknown
            }
            return tile_colors.get(
                tile, (255, 255, 0)
            )  # fallback to red (shouldn't be used)

        cell_size = 60
        cell_border = 5
        header_size = 120

        # set the width and height based on the number of players and cards
        width = len(self.players) * cell_size + header_size
        height = len(self.cards) * cell_size + header_size

        img = Image.new("RGBA", (width, height), (40, 39, 41))  # dark gray background
        draw = ImageDraw.Draw(img)
        font = ImageFont.load_default()

        # drawing headers (players as columns, cards as rows)
        # ChatGPT wrote this, I don't understand it
        for i, player in enumerate(self.players):
            player_position = (header_size + (i + 0.5) * cell_size, header_size / 2)
            draw.text(player_position, player, font=font, anchor="mm", fill="white")
        for j, card in enumerate(self.cards):
            card_position = (header_size / 2, header_size + (j + 0.5) * cell_size)
            draw.text(card_position, card, font=font, anchor="mm", fill="white")
        
        # draw rows one at a time (there are always more cards than players and thus rows than columns)
        for row, card in enumerate(self.cards):
            # look at each player's information for the row
            for col, player in enumerate(self.players):
                information = self.tally_sheet[player][card]
                tile_fill = get_tile_color(information)
                
                # where to start filling in the coloured tile
                tile_top_left = (
                    header_size + col * cell_size + cell_border,
                    header_size + row * cell_size + cell_border,
                )
                # where to stop filling in the coloured tile
                tile_bottom_right = (
                    header_size + (col + 1) * cell_size - cell_border,
                    header_size + (row + 1) * cell_size - cell_border,
                )
                
                draw.rectangle([tile_top_left, tile_bottom_right], fill=tile_fill)

        img.save(filename)
        print(f"Tally sheet drawn and saved as {filename}")

    def store_accusation(self, suspect, weapon, room, responder, response):
        """
        Purpose:
            Records all information generated by an accusation.
        Pre-conditions:
            str suspect: the accused suspect.
            str weapon: the accused weapon.
            str room: the accused room.
            str responder: the player responding to the accusation.
            str response: the response to the accusation. "y" for yes, "n" for no.
        Post-conditions:
            self.tally_sheet: the tally sheet may be updated with the new information.
            self.links: a new link may be added if the response is positive.
        Returns:
            None.
        """
        if response not in ["y", "n"]:
            raise ValueError("Response must be 'y' for yes or 'n' for no")

        # create a link on the cards if the response is positive
        if response == "y":
            self.links.append((responder, [suspect, weapon, room]))
        # mark all cards as false if the response is negative
        elif response == "n":
            for card in [suspect, weapon, room]:
                if card in self.cards:
                    self.tally_sheet[responder][card] = False

    def store_revealed_card(self, player, card):
        """
        Purpose:
            Record when a card is explicitly revealed to you.
        Pre-conditions:
            str player: the player who revealed the card.
            str item: the card that was revealed.
        Post-conditions:
            self.tally_sheet: the tally sheet is updated with the new information.
        Returns:
            None.
        """
        if player not in self.players or card not in self.cards:
            raise ValueError("Invalid player or card")
        self.tally_sheet[player][card] = True

    def update_tally_sheet(self):
        """
        Purpose:
            Make as many deductions as possible based on the current information.
        Pre-conditions:
            None.
        Post-conditions:
            self.tally_sheet: the tally sheet is updated with new information.
        Returns:
            None.
        """
        changes_made = True
        while changes_made:
            changes_made = (
                self.__check_full_hands()
                or self.__check_found_cards()
                or self.__resolve_links()
            )

    def __check_found_cards(self):
        """
        Purpose:
            When a card is known to be in a hand, nobody else is holding it.
        Pre-conditions:
            None.
        Post-conditions:
            self.tally_sheet: the tally sheet is updated with new information.
        Returns:
            bool: True if changes were made, False otherwise.
        """
        changes_made = False
        for card in self.cards:
            owners = [
                player
                for player, cards in self.tally_sheet.items()
                if cards[card] is True
            ]
            if len(owners) == 1:
                for player in self.players:
                    if player not in owners and self.tally_sheet[player][card] is None:
                        self.tally_sheet[player][card] = False
                        changes_made = True
        return changes_made

    def __check_full_hands(self):
        """
        Purpose:
            When a player's whole hand is known, mark the other cards as false.
        Pre-conditions:
            None.
        Post-conditions:
            self.tally_sheet: the tally sheet is updated with new information.
        Returns:
            bool: True if changes were made, False otherwise.
        """
        changes_made = False
        for player, player_cards in self.tally_sheet.items():
            if list(player_cards.values()).count(True) == self.hand_size:
                for card, value in player_cards.items():
                    if value is None:
                        self.tally_sheet[player][card] = False
                        changes_made = True
        return changes_made

    def __resolve_links(self):
        """
        Purpose:
            Resolve links using deduction. If a player does NOT have two cards, they have the third.
        Pre-conditions:
            None.
        Post-conditions:
            self.tally_sheet: the tally sheet is updated with new information.
        Returns:
            bool: True if links were resolved, False otherwise.
        """
        changes_made = False
        updated_links = []
        for link in self.links:
            responder, linked_cards = link
            known_cards = [
                card
                for card in linked_cards
                if any(
                    self.tally_sheet[player][card] == True for player in self.players
                )
            ]

            if len(known_cards) == len(linked_cards) - 1:
                unknown_card = next(
                    card for card in linked_cards if card not in known_cards
                )
                if self.tally_sheet[responder][unknown_card] is None:
                    self.tally_sheet[responder][unknown_card] = True
                    changes_made = True
            else:
                updated_links.append(link)

        self.links = updated_links
        return changes_made


class Clue(object):
    def __init__(self, game_path):
        self.board = []  # the game board
        self.cpu_location = (None, None)  # the CPU location
        self.cpu_suspect = None  # the CPU suspect
        self.rooms = []  # list of room names
        self.suspects = {}  # key: suspect name, value: (x, y) starting position
        self.suspect_order = []  # the order of the players
        self.tallysheet = None  # the clue tracker
        self.weapons = []  # list of weapon names

        self.__read_board_data(game_path)

    def initialize_game(self):
        """
        Purpose:
            Initializes the game with the two required user inputs before the main loop.
        Pre-conditions:
            None.
        Post-conditions:
            self.suspect_order, self.cpu_suspect, self.cpu_location are populated.
        Returns:
            None.
        """
        print("Welcome to Clue!")
        self.__prompt_game_order()
        self.__prompt_cpu_suspect()
        cpu_cards = self.__prompt_cpu_cards()
        self.cpu_location = self.suspects[self.cpu_suspect]
        self.tallysheet = ClueTracker(
            self.suspect_order.copy(),
            list(self.suspects.keys()).copy(),
            self.weapons.copy(),
            self.rooms.copy(),
            cpu_cards,
            self.cpu_suspect,
        )

    def run_game(self):
        """
        Purpose:
            The main loop of the game. Handles CPU and player turns until a final
            accusation on the part of the CPU is made.
        """
        accusation_made = False
        while not accusation_made:
            # run through the player order
            for player in self.suspect_order:
                # handle human turns
                if player != self.cpu_suspect:
                    self.__human_turn(player)
                # handle CPU turn
                else:
                    accusation_made = self.__cpu_turn()
            print(self.tallysheet.tally_sheet)
            print(self.tallysheet.links)
            self.tallysheet.draw_sheet("tallysheet.png")

    def __cpu_turn(self):
        print("CPU turn not implemented.")

    def __get_attribute_name(self, provided_attribute, attributes):
        """
        Purpose:
            Get the attribute name from a list of attributes.
        Pre-conditions:
            str provided_attribute: the attribute to find.
            list attributes: the list of attributes to search.
        Post-conditions:
            None.
        Returns:
            str: the attribute name.
        """
        # search for the attribute in the list of attributes
        for attribute in attributes:
            if provided_attribute.lower() in attribute.lower():
                return attribute

    def __get_next_player(self, current_player):
        """
        Purpose:
            Get the next player in the order of play.
        Pre-conditions:
            str current_player: the current player.
        Post-conditions:
            None.
        Returns:
            str: the next player.
        """
        current_index = self.suspect_order.index(current_player)
        return self.suspect_order[(current_index + 1) % len(self.suspect_order)]

    def __get_tile_position(self, tile):
        """
        Purpose:
            Get the position of a tile on the board.
        Pre-conditions:
            str tile: the tile to find.
        Post-conditions:
            tuple: the position of the tile.
        Returns:
            tuple: the position of the tile.
        """
        for y, row in enumerate(self.board):
            for x, board_tile in enumerate(row):
                if board_tile == tile:
                    return (x, y)

    def __hand_size(self):
        """
        Purpose:
            Get the size of each player's hand.
        Pre-conditions:
            None.
        Post-conditions:
            None.
        Returns:
            int: the size of each player's hand.
        """
        return (len(self.suspects) + len(self.weapons) + len(self.rooms)) // len(self.suspect_order)


    def __human_turn(self, player):
        room, weapon, suspect = self.__prompt_human_accusation(player)

        is_card_revealed = "n"
        questioned_player = self.__get_next_player(player)
        while is_card_revealed != "y":
            # no players could reveal a card and the accusation looped back to the accuser
            if questioned_player == player:
                return

            # note if the accused player revealed a card
            is_card_revealed = input(
                f"Did {questioned_player} reveal a card to {player} (y/n)? "
            ).lower()
            self.tallysheet.store_accusation(
                suspect, weapon, room, questioned_player, is_card_revealed
            )
            questioned_player = self.__get_next_player(questioned_player)


    def __prompt_cpu_cards(self):
        """
        Purpose:
            Prompts the user to enter the cards the CPU has.
        Pre-conditions:
            None.
        Post-conditions:
            None.
        Returns:
            List[str]: the cards the CPU has.
        """
        # get the cards from user
        cpu_cards = []
        while len(cpu_cards) < self.__hand_size():
            card = input(f"Enter the card the CPU has ({len(cpu_cards) + 1}): ")
            card = self.__get_attribute_name(card, list(self.suspects.keys()) + self.weapons + self.rooms)
            if card and card not in cpu_cards:
                cpu_cards.append(card)
            else:
                print("Error: card already entered. Please enter a new card.")
        return cpu_cards

    def __prompt_cpu_suspect(self):
        """
        Purpose:
            Prompts the user to select the CPU suspect.
        Pre-conditions:
            self.suspect_order must have been populated.
        Post-conditions:
            self.cpu_suspect: the CPU suspect.
        Returns:
            None.
        """
        # get the CPU suspect from the user
        cpu_suspect = None
        while cpu_suspect not in self.suspect_order:
            entered_cpu = input(f"Enter the CPU suspect({self.suspect_order}): ")
            cpu_suspect = self.__get_attribute_name(entered_cpu, self.suspect_order)

        # save to the object the suspect as named in self.suspect_order
        self.cpu_suspect = self.__get_attribute_name(cpu_suspect, self.suspect_order)

    def __prompt_game_order(self):
        """
        Purpose:
            Prompts the user to enter the player order. The players entered must be
            contained as characters within the suspects list.
        Pre-conditions:
            self.suspects must have been populated.
        Post-conditions:
            self.suspect_order: a list of the suspects in the order they are playing.
        Returns:
            None.
        """
        is_valid_order = False
        # get the order of the players
        while not is_valid_order:
            print("Enter the order of the players, separated by commas.")
            user_order = [suspect.strip() for suspect in input().split(",")]
            validated_suspects = []

            actual_suspects = [key for key in self.suspects.keys()]
            for user_suspect in user_order:
                # check if the suspect is valid
                validated_suspect = self.__get_attribute_name(
                    user_suspect, actual_suspects
                )
                validated_suspects.append(validated_suspect)
                actual_suspects.remove(validated_suspect)

            # make sure 2 or more players are in the game
            if len(validated_suspects) < 2:
                print(
                    f"Error: you must have at least 2 valid players. You entered {validated_suspects}."
                )
                continue

            # use the validated order
            self.suspect_order = validated_suspects
            is_valid_order = True

    def __prompt_human_accusation(self, player):
        room, weapon, suspect = None, None, None
        while True:
            accusation = [
                info.strip()
                for info in input(f"{player} accused (room, weapon, suspect): ").split(
                    ","
                )
            ]
            room = self.__get_attribute_name(accusation[0], self.rooms)
            weapon = self.__get_attribute_name(accusation[1], self.weapons)
            suspect = self.__get_attribute_name(accusation[2], self.suspects.keys())

            if not room or not weapon or not suspect:
                print("Error: invalid accusation. Please try again.")
                continue
            break

        return room, weapon, suspect

    def __read_board_data(self, game_path):
        """
        Purpose:
            Read the clue game board from a specified path.
        Pre-conditions:
            str game_path: the path to the game board. MUST BE properly formatted.
        Post-conditions:
            self.board: a list of lists representing the game board (players are removed).
            self.rooms: all of the rooms in the game.
            self.suspects: all of the suspects in the game.
            self.weapons: all of the weapons in the game.
        Returns:
            None.
        """
        with open(game_path, "r") as f:
            # first line is weapons
            self.weapons = f.readline().rstrip().split(",")

            # the rest of the lines are the board
            tile_rows = f.readlines()
            for y_coord, tile_row in enumerate(tile_rows):
                tiles = tile_row.rstrip().split(",")
                for x_coord, tile in enumerate(tiles):

                    if tile not in [" ", "x", "Door"]:
                        # this is a suspect since it is on the edge
                        if (
                            y_coord == 0
                            or y_coord == len(tile_rows) - 1
                            or x_coord == 0
                            or x_coord == len(tiles) - 1
                        ):
                            self.suspects[tile] = (x_coord, y_coord)
                        # otherwise it's a room
                        else:
                            if tile not in self.rooms:
                                self.rooms.append(tile)

            # save the board to the object
            for line in f:
                # read row
                row = line.rstrip().split(",")
                # remove suspects from the board
                for i, tile in enumerate(row):
                    if tile in self.suspects.keys():
                        row[i] = " "
                self.board.append(row)


def main():
    game = Clue("board.csv")
    game.initialize_game()
    game.run_game()


if __name__ == "__main__":
    main()


def draw_board(filename, board):
    """
    Creates an image of the board and saves it to a file with coloured tiles and
    text annotations.
    """
    from PIL import Image, ImageDraw, ImageFont

    def get_tile_color(tile):
        """Returns the color corresponding to the tile type."""
        tile_colors = {
            "x": (40, 39, 41),  # walls are dark gray
            " ": (226, 200, 60),  # floors are classic yellow
        }
        return tile_colors.get(tile, (255, 0, 0))  # use red for all other tiles

    cell_size = 50
    cell_border = 2
    font_size = 12

    width, height = len(board[0]) * cell_size, len(board) * cell_size

    img = Image.new("RGBA", (width, height), "black")
    draw = ImageDraw.Draw(img)
    try:
        # attempt to load a truetype or opentype font file
        font = ImageFont.truetype("arial.ttf", font_size)
    except IOError:
        # fall back to a default font if unable to load
        font = ImageFont.load_default()

    for i, row in enumerate(board):
        for j, tile in enumerate(row):
            fill = get_tile_color(tile)
            top_left = (j * cell_size + cell_border, i * cell_size + cell_border)
            bottom_right = (
                (j + 1) * cell_size - cell_border,
                (i + 1) * cell_size - cell_border,
            )
            draw.rectangle([top_left, bottom_right], fill=fill)

            # check if tile needs text
            if tile not in ["x", " "]:  # floors and walls don't need text
                text_position = (
                    j * cell_size + cell_size // 2,
                    i * cell_size + cell_size // 2,
                )
                draw.text(text_position, tile, font=font, anchor="mm", fill="black")

    img.save(filename)
    print(f"Board drawn and saved as {filename}")
